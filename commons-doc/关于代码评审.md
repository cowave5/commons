很多团队都会面临这样的问题，开发人员水平参差不齐，代码写的不够规范，Review又觉得费时费力。以下是我们总结的一些关于代码质量管理与提升的思考，也参考了一些他人的经验。



### 评审的目的

代码评审的主要目的是希望随着时间的推移，代码能够越来越健康，而不是放任其腐化下去，越来越混乱，以至于最后不得不推倒重来。大多情况下，代码的质量都会随着时间推移而越来越差，尤其是在团队有明确时间限制，让开发觉得不得不采取一些投机取巧的方式才能完成任务的情况下。

评审的另一个目的是希望能提升团队技术氛围，很多时候我们一味的埋头苦干，很容易忽视团队内的技术分享，再加上团队人员进进出出，有一些正能量的人自然也有负能量的人，这都很正常。但不管怎样我们相信做技术的人都愿意提升自己的技术能力，通过分享，将每个人擅长的领域分享给大家，互相学习来提升凝聚力和团队水平。



### 评审的原则

评审者不必要求开发者打磨好提交中的每个细节，而是应该权衡项目进度和开发给出的意见重要性，适当放宽要求。我们并不是要追求完美，也很难有完美无缺的代码，只是希望通过评审这个手段来提升整个系统代码的可维护性、可读性或者可理解性。

在实际开发中，我们一般要求最低要能保证代码的结构层次清晰，逻辑段落分明，风格简单符合直觉。当然，我们的目标是力求简洁优雅的代码，并能准确直白的表达出自己的意图，尽力向高内聚、低耦合这种目标靠近。

- 技术和数据高于意见，鼓励质疑，尊重个人偏好；

- 遵守开发规范，保持代码风格（关于风格应该与现有的保持一致，如果以前没有风格，可以就按作者的风格来）；

- 软件设计从来不是纯粹的代码风格或是个人偏好问题，它们是基于一些应当被权衡的规则而不仅仅是个人倾向；

  

### 评审关注点

代码评审中比较重要的一点是理解开发者提交变更的意图，把握住变更中的整体设计

- 设计良好：保证良好的设计，不管是需求设计还是存储设计、接口Api、或是算法流程。如果有设计文档，应当保证文档与实现同步；

- 提交说明：描述清楚提交的内容，言简意赅，并保持语义完整。保证提交的变更符合描述，尽量一次变更只做一件事情；

- 文件组织：保证文件结构清晰，尽量按照默认的约定，比如springboot中的相关配置文件，mvc中的代码层次组织；

- 命名语义：保证语义清晰，包括文件、库表字段、以及类、方法变量等，通过命名能直接明白其职责，最好能通过命名对文件完成自然的分类；

- 代码风格：保证格式化，逻辑层次清晰，比如通过一些空行，方法拆解，来体现层次感；我们鼓励对代码风格提出改进建议，但要避免吹毛求疵，尤其是通过一些评审工具给出的建议，可以视为锦上添花。

- 职责单一：不管是类、接口、还是方法的定义，它们都应该有自己的角色，应该保证它们的分工明确，职责清晰；

- 复杂度：通常单个方法的复杂度不应该过高，除非一些特殊情况，比如复杂的算法。在设计上，如无必要，不要增加复杂度。我们鼓励通过设计来提高可扩展性，但不要为了扩展一些不存在的场景而过度设计，应该反思新增的复杂度是否值得；

- 代码注释：准确而必要的注释（错误的注释不如没有，不必要的注释会增加维护负担）。不应该为了注释率而添加一些显而易见的废话，应该说明代码中没有包含的信息，比如业务实现背景，或者为什么这样做的考虑。当然对于一些复杂的算法或正则表达式等，如果能直接添加说明是可以帮助别人更好的理解；

- 单元测试：单元测试并不只是要求大家去编写枯燥的测试代码，以满足覆盖率的要求，其意义在于能够驱动开发去反思自己的代码设计。如果你的代码在编写单元测试时很痛苦，那么可以思考下如何改进代码设计，使其满足职责单一的原则。大多同学都是在代码写完之后，再去补充单元测试，其实你可以在编写代码之前，就思考一下如何设计可以更方便进行代码测试。

- 线程安全：对于涉及到可变共享资源的访问，需要格外留意线程安全问题；

### 评审步骤

这里主要针对的是线下组织的评审会议，为了避免会议中的讨论走题浪费时间，所以我们应该在会前明确好主要议题和流程

1. 评审范围，首先明确改动涉及范围，比如一次变更提交，某个功能或者模块；

2. 需求背景，说明改动的意图，说清楚做了什么，期望达到什么目的；

3. 设计思路，怎样做的，说明白实现思路；

4. 代码实现，对照设计思路说明代码中的关键实现；

5. 遗留问题，在设计实现过程中是否还有一些未完成的Todo，或者一些妥协；

6. 评审意见，可以通过在git提Issues，或者类似Jira的项目管理工具上提问题的方式进行跟进，由被评审人落实修改；

   

### 评审过程实践

- 代码提交

作为开发人员，写清楚提交说明是一个必要的职业素养，至于一些不按照规范来写的开发可以对他们提出要求。为了将提交记录与具体的开发任务关联起来，我们可以采用 git + jira 的方式，让开发人员在每次提交的comment中增加jira编号；

但这只是一个规范，如何将规范真正落地，避免开发人员在comment中忘记，可以采用一些工具帮助开发人员在提交时进行检查。git的hook机制在代码提交前后提供了一些钩子，可以用来控制提交允许或拒绝，比如说pre-commit或commit-msg；

可以要求使用Idea的git commit message插件来进行提交，保持统一格式，方便通过maven插件来生成更有意义的changelog；

- 代码检查

对于编码规范，我们可以采用sonar扫描问题，但这个方式的缺点是太过滞后，需要质量人员去跟进和推动修改，而且效果也不是很好。因为大多开发都有一种习惯，如果代码写完上线之后没有问题，他们很少会主动去优化代码，即使你告诉他扫描有问题他也会有各种理由推脱。也许你可以通过管理手段强制他们修改，但这些方式还是比较滞后而且不愉快。

可以考虑采用 git + checkstyle或fingbug等工具插件，来前置检查点帮助开发人员在开发过程中就发现问题并进行解决。对于Java开发，在Maven构建中，也有代码检查的相关plugin，比如我们采用的pmd检查，当然也有checkstyle或findbugs。

- 代码分支

团队中的每个人或多或少对git的管理与使用理解有些不一致，可能造成分支、版本管理的混乱，这样在代码合并时可能产生一些不必要的冲突。我们可以制定一套规范性的东西，来进行进行分支和版本的管理，让开发在可控的范围内自由发挥。

- 代码评审

比较常见的方式是团队内定期组织全体开发人员进行集中式的code review，但长期这样会有些费时费力。可以参考开源团队，利用工具在线来进行review。比如说github有pull request，gitlab有merge request，可以在代码合并的节点上进行review，这样的好处是比较开放，而且可以留下review记录，互相的想法和沟通建议都可以很好的留存下来并通过UI的方式友好的展示出来。



### 代码示例

这里以开发常用的常量类和工具类作为示例来说明（我们不推荐随意定义这种Constants常量类以及Util工具类，因为是面向对象编程，通常每个属性常量或方法行为，应该都有它归属的对象模型）

比如：

```java
public class Constants {

    /** 性别：男 */
    public static final int SEX_MALE = 0;

    /** 性别：女 */
    public static final int SEX_FEMALE = 1;

    /** 状态：打开 */
    public static final int STATUS_OPEN = 1;

    /** 状态：关闭 */
    public static final int STATUS_CLOSE = 0;
}
```

这里定义了两组常量，性别和岗位的状态。但如果还有一个其他的数据模型也有状态这个属性，那么是让它复用这里岗位状态，还是通过前缀区分再加一组状态常量呢。虽然都可以，但肯定不如直接将这个状态常量放到对应的对象模型中来得更加直白。

由于Constants并没有具体的业务含义，那么它就可以容纳任何的常量定义。但是当定义的常量变多之后，就容易变得混乱。如果项目中发生人员变动或交接，后面接手的开发同学很容易继续向其中添加更多的常量，导致重复和更多的混乱。

```java
public class SysPost {

    /** 状态：打开 */
    public static final int STATUS_OPEN = 1;

    /** 状态：关闭 */
    public static final int STATUS_CLOSE = 0;

    // ... 
}
```

同样的对于一个方法，如果并不具备独立出来进行复用的价值，那么也不应该定义成Util工具方法，而应该尽量定义到它所属的类型中。对于那些确实应该定义成Util的方法，建议先检查一下这样的方法是否已经存在了，比如Apache的commons库，或者Hutool等第三方库，而且我们也定义了一个commons-tool包，专门用来归纳收集这些常用的Util。



### 附录

#### 版本管理

目标是保证所有里程碑式的产物都能有对应的版本跟踪，并且作为结果归档是不可改变的；

- 发布版本（Tag）

使用简单的语义化版本规范：`{主版本号}.{次版本号}.{修订版本}`

`{主版本号}`：跟踪重大功能变动或重构升级；

`{次版本号}`：跟踪发布或迭代周期；

`{修订版本}`：跟踪版本发布之后的修订；



- 测试回归版本（Tag）

或者称为alpha版本，约定在发布版本的基础上添加后缀：`{主版本号}.{次版本号}.{修订版本}-{alpha版本}`

与发布版本的区别：

```tex
发布版本是作为结果产物交付给客户的，回归版本是交给内部测试进行验证的，是发布版本之前的阶段性产物，最后一次回归版本通过后，发布版本；
发布版本作为一种资源，对于同一个功能开发或同一个问题修订，不应该反复浪费多个多个版本，通过中间的回归版本应该能将问题真正结束掉；
```



- 开发构建版本

在回归版本的基础上添加构建号作为后缀：`{主版本号}.{次版本号}.{修订版本}-{alpha版本}-build{构建号}`

一般构建工具都会记录一个构建序列，比如jenkins的build号；

在交给测试走回归验证之前，可能开发自己需要构建验证若干次，对于每一次构建出包的版本也需要能够区分（可能有多个测试环境，比如在alpha1阶段，如果开发构建进行部署验证，就需要区分这些环境分别部署的是哪次构建的）



**场景：** 迭代开发

```tex
首轮迭代开始，产品规划起始版本1.0.0
第一轮开发测试，开发过程基于版本1.0.0-alpha1-build{构建号} 构建打包验证，结束后出版本1.0.0-alpha1 交给测试进行回归验证；
第二轮开发测试（如果上一轮回归未通过），那么进入alpha2阶段，结束后出版本1.0.0-alpha2 再交给测试走回归验证；
重复过程，直至在版本1.0.0-alpha{N} 问题全部解决，发布迭代版本1.0.0

下一轮迭代，产品规划版本1.1.0，然后以同样的方式进行测试回归，直至可以发布迭代版本1.1.0；
```



**场景：** 版本修订

针对已发布的版本，如果出现Bug（理论上应该极力避免这种情况），那么我们可以找到发布版本对应的Tag，check出版本修订分支进行修改，然后验证并发布对应的修订版本；

```tex
假设1.0.0的发布版本出现Bug，那么它对应第一次修订版本为: 1.0.1
第一轮修订，开发过程基于版本1.0.1-alpha1-build{构建号} 构建打包验证，结束后出版本1.0.1-alpha1 交给测试进行回归验证；
第二轮修订（如果上一轮回归未通过），那么进入alpha2阶段，结束后出版本1.0.1-alpha2 再交给测试走回归验证；
重复过程，直至在版本1.0.1-alpha{N} 问题全部解决，发布修订版本1.0.1

不过这样可能还没有完全解决问题，如果此时我们发布的版本已经到了1.5.x；
那么1.1.x到1.4.x的发布版本中是否都存在此Bug，是否都要进行修订；
此时：
要么是针对这些中间版本分别都发布修订版本，比如将1.1.2修订为1.1.3，将1.2.4修订为1.2.5，其中每个修订版本的发布也都类似于上面的1.0.1，需要走一遍测试回归流程;
或者直接放弃中间版本的修订，只承诺在1.5.x及之后的版本中解决此Bug；
```



- **补充说明：** 产品版本

上面的版本说明，是以具体的应用模块开发来作为跟踪对象（由研发负责），但是对于一个产品，它可能包含多个应用模块，并且各个应用模块的版本不同；此时我们需要针对产品整体定义一个独立的版本路线，使用同样的版本管理方法；

产品的版本可以交给（产品测试）负责，由他们负责将所有需要的应用模块收集，制定一个产品版本，并记录产品版本与各个应用模块的版本关系；另外，应用模块的版本号，建议根据产品版本的规划来制定，示例如下

```tex
假设当前的产品版本为1.0.0，其中包含A、B、C、D四个应用模块；

现在要规划产品版本1.1.0，但是只需要变动其中的C、D；
那么在发布产品1.1.0时，对应的应用模块版本就是，A(1.0.0)、B(1.0.0)、C(1.1.0)、D(1.1.0)

下次可能产品规划1.2.0，但只需要变动应用模块B（此时B的版本可以直接跳过1.1.x，跟着产品进入1.2.x）；
那么在发布产品1.2.0时，对应的应用模块就是，A(1.0.0)、B(1.2.0)、C(1.1.0)、D(1.0.0)

对于每次发布版本的修订，产品版本也通过修订版本来跟踪
比如应用C的1.1.0版本需要修订为1.1.1，那么产品1.1.0和1.2.0如果要发布修订版本的话，分别如下：
产品版本（1.1.1），对应应用模块 A(1.0.0)、B(1.0.0)、C(1.1.1)、D(1.1.0)
产品版本（1.2.1），对应应用模块 A(1.0.0)、B(1.2.0)、C(1.1.1)、D(1.0.0)
```



#### 分支管理

不管是以怎样的形式，开发都应该养成修改前先拉分支的习惯，这样可以尽量将开发功能的提交隔离，方便在发布时选择性的发布功能。

一般可以通过业务需求Id或Bug单号来标识分支，比如feat-xx/fix-xx，如果功能是多人协作开发，可以继续在feat/fix的基础上再拉个人开发分支（所有的临时分支在合并之后应该及时删除）；

比如小A同时开发两个特性，直接在主分支上开发，且穿插提交记录，那么在发布时如果希望只发布其中一个功能就比较麻烦；如果在开发之前先分别拉两个临时功能分支，然后在临时功能分支上分别进行开发和验证，最后再决定是否合并到主分支，虽然这样在合并时可能要处理一些冲突（可以通过一些代码结构设计来避免），但是保证了功能提交隔离和一定的发布灵活性；



- 常规开发

对于正常的开发，我们一般只需保留一个`master`主分支（限制push与merge权限），然后在此基础上拉取临时开发分支；



**场景：** 迭代需求开发

```tcl
迭代需求分支: {迭代版本}-{alpha版本}-feat-{需求Id}-{其它标识} 
基于主分支创建的临时分支，用于迭代需求开发，通常结合jira等项目管理工具，以一个发布周期或者一个迭代来标识分支；

版本分支：对应版本管理说明，假设当前是开发1.1.0版本的alpha阶段，那么先拉取一个版本分支：1.1.0-alpha1（限制push与merge权限）；
需求分支：如果一个迭代有多个需求，可以继续在1.1.0-alpha1基础上拉取需求开发分支：1.1.0-alpha1-feat1、1.1.0-alpha1-feat2等；
协作分支：如果一个需求由多人协作开发，可以继续拉取分支1.1.0-alpha1-feat2-zhang3、1.1.0-alpha1-feat2-li4等；

分支的合并是相反过程，逐层进行合并，先将协作分支合并到需求分支，需要基于需求分支进行构建并验证，如果通过再合并（MR）到版本分支，并删除自己。当所有需求分支都合并之后，再基于版本分支进行构建，然后出版本1.1.0-alpha1，交给测试走回归验证；

在需求分支向版本分支合并时，需要提交Merge Request，由评审人介入code review进行合并（评审人可以要求开发通过git rebase整理下提交记录，因为开发过程中可能会产生一些重复且没有意义的commit-log，如果对其进行合并整理，可以减轻代码评审的工作量，也使提交记录更清晰）

至于最终的版本分支是否要合并到主分支，则根据实际情况来决定（可能版本分支最后衍化成一个定制，成为了独立的主分支）
```



**场景：** 迭代问题回归

```tex
测试回归分支: {迭代版本}-{alpha版本}-fix-{Bug单号}-{其它标识}
一般是基于主分支创建的临时分支，用于测试回归问题修复，同样结合jira等项目管理工具，以Bug单号来标识分支；

版本分支：对应版本管理说明，如果1.1.0-alpha1（已结束）走回归验证未能通过，那么再起一个alpha版本，对应拉取分支：1.1.0-alpha2
Bug分支：对于具体的测试Bug修改，可以继续在1.1.0-alpha2版本分支基础上拉取分支：1.1.0-alpha2-fix1、1.1.0-alpha2-fix2等；

同样当Bug改完之后，需要基于Bug分支进行构建并验证，如果通过再合并（MR）到版本分支，并删除自己。当所有Bug问题都完成修改合并，再基于版本分支进行构建，然后出版本1.1.0-alpha2，并交给测试走回归验证；

在经过几次alpha版本之后，由（产品测试）确认应该修复的问题都已修复，最终发布迭代版本：1.1.0
```



**场景：** 版本问题修订

```tex
版本修订分支：{修订版本}-{alpha版本}-fix-{Bug单号}-{其它标识}
针对已发布的版本，如果发现Bug，那么先基于版本Tag创建修订分支，专门用于修订此版本问题，比如版本1.0.0对应创建修订分支为：1.0.0-fix

与上面过程类似：
版本分支：在修订分支的基础上先拉取alpha版本分支（上面迭代过程中，是基于主分支拉取），比如：1.0.1-alpha1
Bug分支：同样对于具体的问题修改，可以继续在1.0.1-alpha1上拉取分支：1.0.1-alpha1-fix1、1.0.1-alpha1-fix2等；

当Bug改完之后，也是基于Bug分支进行构建验证，如果通过再合并（MR）到版本分支，并删除自己。当所有Bug问题都完成修改合并，再基于版本分支进行构建，然后出版本1.0.1-alpha1交给测试走回归验证；当在alpha版本确认问题已修复后，最终发布修订版本：1.0.1，并合并到修订分支；

对于修订分支是否要合并到主分支，要根据情况来决定（也许当前的主分支经过发展已经不再兼容），最坏的情况可能需要针对多个已发布的版本分别进行修订和发布；
```



- **补充说明:**  多环境

如果条件允许，我们可能会将环境分成多个层次，比如：dev开发环境，beta测试环境，release预发布环境，以及prod生产环境；

此时对应会保留多个主分支（相对上面单个主分支，全部由开发进行管理，这里需要开发、测试、运维分权进行管理）：

```te
master:  开发环境分支，还是由开发负责，开发环境基于此分支进行构建；
beat:    测试环境分支，由测试负责；开发在dev环境通过验证后，申请转测试，此时开发需要向测试承诺转测的功能正常；
release: 预发布环境分支，由运维负责；测试在beat环境验证通过之后，申请转发布，此时测试需要向运维承诺待发布的功能都正常；
prod:    生产环境分支，由运维负责；这一步可以是自动的，只要根据发布计划，将release分支的记录向prod同步就行；

这些分支的版本关系有一定的先后关系：master > beat > release > prod
(具体建立多少个主分支，可能根据实际情况调整，这里作为一个参考说明)
```



- **补充说明:**  定制版本

如果同一个应用存在不同的定制化需求，且互相不兼容，那么此时只有一个主分支就不能满足了；

可以创建多个主分支（通过一些定制简写来标识分支），来应对不同的定制开发，至于每个主分支中的版本开发管理则与上面保持不变；



**其它场景：** 

- 迭代重合

比如1.1.0正在测试回归阶段，现在要开启1.2.0的迭代开发；

这种情况同样先拉取一个1.2.0-alpha1的版本分支，问题只在于是从主分支上拉，还是从1.1.0-{alpha版本}的迭代分支上拉，这个可以根据实际情况来决定：

如果1.1.0已经合并到了主分支（一般会阶段性合并到主分支），那么可以直接从主分支上拉取；

如果1.1.0未合并到主分支（可能不确定最终是否要合并主分支，比如一些试验性的功能，为了招标所开发的需求），此时就看1.2.0是否要包含1.1.0开发的内容，如果要包含就从1.1.0分支上拉，否则还从主分支上拉取；



- 功能独立发布

比如一个迭代中计划开发多个功能，然后某个功能要提前单独发布（需求规划阶段应尽量避免）；

可能发生了破坏性的修改或重构，可以规划一个大版本号来拉取分支，专门用来跟踪这个功能及后续的变化；

或者直接走定制版本路线，新建一个主分支（区分当前主分支，独立命名）来跟踪变化，对应可以在发布版本时添加一个功能前缀；



#### 提交描述规范

这里我们借鉴Idea中的Git提交插件，其采用的Angular 规范；

规范的格式中包括3部分内容：Header、Body、Footer

- Header

  Header格式：` type(scope): subject` ，举例：`feat(用户模块): 新增用户查询接口`

  type：必填，表示提交类型，由如下选择（当然我们也可以自定义添加一些自己的type，保持格式统一就行）：

  ```tex
  feat：    (常用)新功能feature
  fix：     (常用)修补bug
  docs：    文档documentation
  style：   格式（不影响代码运行的变动,空格,格式化,等等）
  refactor：重构（即不是新增功能，也不是修改bug的代码变动
  perf:   性能 (提高代码性能的改变)
  test：  增加测试或者修改测试
  build:  影响构建系统或外部依赖项的更改(maven,gradle,npm 等等)
  ci:     对CI配置文件和脚本的更改
  chore:  对非 src 和 test 目录的修改
  revert: Revert a commit
  ```

  scope：选填（建议必填），用于说明commit的影响的范围，自行描述；

  subject：必填，commit的简短描述，比如变更的主要目的；

  

- Body

  对本次 commit 的详细描述，可分成多行，如果觉得Header中subject已经描述足够清楚了，则Body部分可以省略



- Footer

  Breaking changes:  提示不兼容的变动；

  Closed issues:  关闭的issue，对应的可以填写Jira任务或Bug单号，或者其它项目管理工具，比如TeamBeation等；

  [skip ci] ：标识是否跳过构建
  
  

建议流水线的构建动作通过commit-log来触发，不要通过推送Tag来触发，避免只是为了构建而产生一些没有意义的Tag；

```tex
可以约定触发构建的commit-log格式：[Build] 和 [Tag]

如果commit描述包含[Build]，那么push代码会触发构建，并且出包时会在版本后面上build后缀，比如：1.1.0-alpha1-build{构建号}；
如果同时包含[Tag]，那么构建出包的版本不会带上buil后缀，另外会打一个Tag推送仓库；

至于版本获取，根据各语言默认的约定来，比如Java应用可以从pom文件中获取；
```



#### 评审者的自我修养

- 业务能力

  评审人员首先要了解所在公司或项目团队的业务领域。只有深入了解业务目标和需求，才能更好地理解代码变更的影响和潜在风险。此外，业务能力还包括对行业趋势和竞争环境的敏感度，对市场需求、产品特点等方面的敏锐洞察力，以便能够做出符合战略方向的决策。只有深入了解业务本质，才能在技术开发和管理决策中做出准确的判断和选择。培养业务能力的方法包括积极参与业务相关的会议和培训，与产品经理和业务部门密切合作，不断学习和更新业务知识。

- 工程能力

  工程能力是指评审人员在软件开发生命周期中的整体把控能力。需要了解软件开发过程中的各个环节，包括需求分析、设计、编码、测试和发布等。同时，还需要具备项目管理和团队协作的能力，能够合理安排资源和时间，推动项目的进展。为了提高工程能力，可以积极参加项目管理和团队协作培训，学习相关的工具和方法，并与开发团队保持密切沟通。

- 技术能力

  作为评审人员，技术能力是必不可少的。需要对多种编程语言和技术框架有深入的了解，能够快速定位和解决技术问题。此外，还需要关注新技术的发展趋势，及时更新自己的知识储备。提升技术能力的方式包括参加技术培训、阅读相关技术书籍和论文，积极参与技术社区的讨论和交流。

- 软能力

  评审人员需要具备良好的沟通能力、领导力、问题解决能力和人际关系处理能力等。要能够清晰地表达自己的意见和建议，有效地与开发团队和其他相关方进行沟通。同时，要能够在面对问题时冷静分析和迅速解决，以及处理好团队内外的人际关系。培养软能力的方法包括参加相关的培训和讲座，多与他人合作并接受反馈，不断提升自己的领导力和沟通能力。
